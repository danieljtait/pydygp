# -*- coding: utf-8 -*-
"""
EM Fit of the MLFM
==================

Uses the EM algorithm to fit estimates of the latent forces for the model

   .. math::

      \dot{\mathbf{x}(t)} = \\left(\mathbf{L}_x + \mathbf{L}_y g_1(t) + \mathbf{L}_z g_2(t) \\right)\mathbf{x}(t)

where :math:`g_1(t)` and :math:`g_2(t)` are independent Gaussian processes, and :math:`\mathbf{L}_i` are the
standard basis of the Lie algebra :math:`\mathfrak{so}(3)` of the rotation group :math:`SO(3)`.
"""
import numpy as np
import matplotlib.pyplot as plt
from scipy.linalg import block_diag
from pydygp.gaussianprocesses import GaussianProcess
from pydygp.linlatentforcemodels import MLFM

def main():

    np.random.seed(122)

    # infinitesimal rotation matrices in so(3)
    Lx = np.array([[0., 0., 0.],
                   [0., 0.,-1.],
                   [0., 1., 0.]])

    Ly = np.array([[ 0., 0., 1.],
                   [ 0., 0., 0.],
                   [-1., 0., 0.]])

    Lz = np.array([[ 0.,-1., 0.],
                   [ 1., 0., 0.],
                   [ 0., 0., 0.]])

    # make the basic mlfm model
    mlfm = MLFM.ns([Lx, Ly, Lz], order=1)

    # latent force gaussian processes
    g_gps = [GaussianProcess('sqexp', kpar=[1., 1.])
             for r in range(len(mlfm.struct_mats)-1)]

    # simulate some data 
    T = 4.
    Nd = 12
    
    tt = np.linspace(0., T, Nd)

    # dense set of times for solving the ODE
    tt_d = np.linspace(0., T, 100)

    # set of times for simulating the latent trajectory
    tt_gp_sim = np.linspace(tt[0], tt[-1], 25)

    y, y_dense, g, _ = mlfm.sim([0., 0., 1.],
                                tt,
                                gps=g_gps,
                                tt_dense=tt_d,
                                tt_gp_sim=tt_gp_sim,
                                return_gp=True)    

    # inital gaussian process approx
    #  - ind. gps, for each dimension
    x0_gps = [GaussianProcess('sqexp') for k in range(3)]

    fig, ax = plt.subplots()

    for N in [5, 7, 12]:

        # reduced inds
        red_ind = np.linspace(0, tt.size-1, N, dtype=np.intp)
        red_tt = tt[red_ind]
        red_y = y[red_ind, :]

        # sets up the em fit
        mlfm.em_fit(red_tt,
                    red_y.T.ravel(),
                    x0_gps=x0_gps, g_gps=g_gps,
                    ifix=N//2-1,
                    h=.25)
        
        mlfm.em.cov_setup()

        ghat = mlfm.em.fit(liktol=1e-3).reshape(mlfm.em.dim.R, mlfm.em.dim.N)
        ax.plot(mlfm.em.comp_times, ghat.T[:, 1], '+', alpha=0.8)

    ax.plot(tt_d, g[:, 1], 'k-', alpha=0.5)

    plt.show()

if __name__ == '__main__':
    main()    

    

    
