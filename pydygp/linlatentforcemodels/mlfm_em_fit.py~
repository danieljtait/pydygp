import numpy as np
from pydygp import nssolve
import scipy.sparse as sparse
from collections import namedtuple
from scipy.linalg import block_diag
from scipy.stats import multivariate_normal

# Model dimensions:
#   N - size of augmented time vector
#   K - dimension of the ambient space
#   R - number of latent forces
Dimensions = namedtuple('Dimensions', 'N K R')

class MLFM_NS_EM:
    """
    Carries out EM estimation of the latent forces in the MLFM model.
    """
    def __init__(self,struct_mats, order=1):
        self.order = order
        self.struct_mats = np.asarray(struct_mats)

        # model dimensions
        self.dim = Dimensions(N=None,
                              K=self.struct_mats[0].shape[0],
                              R=len(self.struct_mats)-1)        


    """
    Model Setup functions
    *********************
    """
    
    def time_input_setup(self, data_times, h=None):
        """
        Sets up the intervals and handles the number of times in each interval
        """
        intervals = [nssolve.ns_util.Interval(ta, tb)
                     for ta, tb in zip(data_times[:-1], data_times[1:])]
        data_inds = [0]
        for I in intervals:
            I.set_quad_style(h=h)
            data_inds.append(data_inds[-1]+I.tt.size-1)
        
        self.intervals = intervals
        self.comp_times = nssolve.ns_util.get_times(self.intervals)
        self.data_inds = data_inds
        self.dim = Dimensions(self.comp_times.size, self.dim.K, self.dim.R)


    def operator_setup(self, ifix=0):
        """
        Setup for the successive approximation operator.
        """
        self.t0 = self.intervals[ifix].ta
        nsop = nssolve.QuadOperator(fp_ind=ifix,
                                    method='single_fp',
                                    intervals=self.intervals,
                                    K=self.dim.K,
                                    R=self.dim.R,
                                    struct_mats=self.struct_mats,
                                    is_x_vec=True)
        self.nsop = nsop        

    """
    Initalise model parameters
    """
    def init_beta(self, beta=1e4):
        self.beta = beta


    def Estep(self, g):
        """
        Returns the mean and covariance of ln p(z | y, g)
        """
        b = self.beta
        D = self.sparse_data_map

        # sparse representation of the transformation matrix
        K = sparse.coo_matrix(self.nsop.x_transform(g, is_x_input_vec=True))

        KtK = K.T.dot(K)
        DK = D.dot(K)
        Ink = sparse.eye(self.dim.N*self.dim.K)

        # for padding the block diag
        zeros = sparse.coo_matrix(np.zeros((self.dim.N*self.dim.K,
                                            self.dim.N*self.dim.K)))

        L0 = self.Lambda0
        LM = self.LambdaM

        if self.order == 1:
            inv_covar = L0 + b*DK.T.dot(LM.dot(DK))
            
            pre_mean = DK.T.dot(LM.dot(self.vecy))

            cov = sparse.linalg.spsolve(inv_covar, sparse.eye(pre_mean.size))
            mean = cov.dot(pre_mean)

            return mean, cov.toarray()

    def loglikelihood(self, y, g):
        """
        Returns the model log-likelihood
        """
        K = self.nsop.x_transform(g, is_x_input_vec=True)

        # recursively construct the cov. function
        cov = self.xcov

        binvI = np.eye(cov.shape[0])/self.beta

        for M in range(self.order):
            cov = np.dot(K, np.dot(cov, K.T)) + binvI

        # data transform
        D = self.data_map
        cov = np.dot(D, np.dot(cov, D.T)) + self.data_covar

        lpy_g = multivariate_normal.logpdf(y, np.zeros(y.size), cov)
        lpg = multivariate_normal.logpdf(g, np.zeros(g.size), self.gcov)

        return lpy_g + lpg

    @property
    def data_map(self):
        """
        Matrix that maps the augmented data x_N to the data
        for which there is an observed time point
        """
        data_map = np.row_stack((np.eye(N=1, M=self.dim.N, k=i)
                                 for i in self.data_inds))
        data_map = block_diag(*[data_map]*self.dim.K)
        return data_map


    @property
    def sparse_data_map(self):
        """
        Sparse representation of the linear transformation y = Dx_N
        """
        try:
            return self._s_data_map
        except:
            D = self.data_map
            self._s_data_map = sparse.coo_matrix(D)
            return self._s_data_map

    @property
    def Lambda0(self):
        try:
            return self._L0
        except:
            xinvs = [sparse.coo_matrix(ci) for ci in self.xcov_invs]
            self._L0 = sparse.block_diag(*[xinvs])
            return self._L0

    @property
    def LambdaM(self):
        try:
            return self._LM
        except:
            Cy = self.data_covar
            Cm = sparse.eye(Cy.shape[0])/self.beta
            LM = sparse.linalg.spsolve(Cy + Cm, sparse.eye(Cy.shape[0]))
            self._LM = LM
            return LM
